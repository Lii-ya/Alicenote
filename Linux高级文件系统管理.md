# Linux高级文件系统管理



[TOC]









## 磁盘配额概述

磁盘配额（Quota）就是Linux系统中用来限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数。



**注意：**

1. 磁盘配额限制的用户和用户组，只能是普通用户和用户组，也就是说==超级用户root是不能做磁盘配额==
2. 磁盘配额限制只能针对分区，而不能针对某个目录，换句话说，**磁盘配额仅能针对文件系统进行限制**
3. 可以==限制用户占用的磁盘容量大小==（block），当然也能==限制用户允许占用的文件个数==（inode）

***



### 配额中的常见概念



**用户配额和组配额**

用户配额是指针对用户个人的配额，而组配额是指针对整个用户组的配额。如果我们需要限制的用户数量并不多，则可以给每个用户单独指定配额。如果用户比较多，那么单独限制太过麻烦，这时我们可以把用户加入某个用户组，然后给组指定配额，就会简单得多。

> ==组中的用户是共享空间或文件数的。==



**软限制和硬限制**

软限制可理解为警告限制，硬限制就是真正限制你的操作行为。



**宽限时间**

如果用户的空间占用数处于软限制和硬限制之间，那么系统会在用户登录时警告用户磁盘将满，但是这个警告不会一直进行，而是有时间限制的，这个时间就是宽限时间，**默认是 7 天。**

==如果到达宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。==





***



### 设置挂载参数usrquota和grpquota





【1】由于Quota仅针对文件系统进行限制，因此需要查一下。/home是否是独立的文件系统，执行命令如下：

```
[root@localhost ~]# df -h /home
Filesystem     Size  Used Avail Use% Mounted on
/dev/hda3      4.8G  740M  3.8G  17% /home  <-- /home 确实是独立的！
```



由于VFAT文件系统并不支持磁盘配额功能，因此也需要检查/home的文件系统

```
[root@localhost ~]# mount | grep home
/dev/hda3 on /home type ext3 (rw)
```

***



## quotacheck命令：扫描文件系统并建立Quota记录文件



> 磁盘配额就是通过分析整个文件系统中每个用户和群组拥有的文件总数和总容量，再将这些数据记录在文件系统中的最顶层目录中，然后在此记录文件中使用各个用户和群组的配额限制值去规范磁盘使用量的。因此，建立quota的记录文件是非常有必要的



扫描文件系统（必须含有挂载参数 usrquota 和 grpquota）并建立 Quota 记录文件，可以使用 quotacheck 命令。此命令的基本格式为：

```
[root@localhost ~]# quotacheck [-avugfM] 文件系统
```


​                                                                               表 1 quotacheck命令常用选项及功能

|    选项    |                             功能                             |
| :--------: | :----------------------------------------------------------: |
|     -a     | 扫瞄所有在 /etc/mtab 中，含有 quota 支持的 filesystem，加上此参数后，后边的文件系统可以不写； |
|     -u     |    针对使用者扫瞄文件与目录的使用情况，会创建 aquota.user    |
|     -g     |    针对群组扫瞄文件与目录的使用情况，会创建 aquota.group     |
|     -v     |                     显示扫瞄的详细过程；                     |
|     -f     |         强制扫瞄文件系统，并写入新的 quota 记录文件          |
| -M（大写） |   强制以读写的方式扫瞄文件系统，只有在特殊情况下才会使用。   |

==在使用这些选项时，读者只需一起下达 `-avug` 即可。至于 -f 和 -M 选项，是在文件系统以启动 quota 的情况下，还要重新扫描文件系统（担心有其他用户在使用 quota 中），才需要使用这两个选项。==



***



## quotaon命令：开启磁盘配额限制


**quotaon 命令的功能就是启动 Quota 服务**，此命令的基本格式为：

```
[root@localhost ~]# quotaon [-avug]
[root@localhost ~]# quotaon [-vug] 文件系统名称
```


​                                                                     表 1 quotaon 命令常用选项及功能

| 选项 |                             功能                             |
| :--: | :----------------------------------------------------------: |
|  -a  | 根据 /etc/mtab 文件中对文件系统的配置，启动相关的Quota服务，如果不使用 -a 选项，则此命令后面就需要明确写上特定的文件系统名称 |
|  -u  |        针对用户启动 Quota（根据记录文件 aquota.user）        |
|  -g  |       针对群组启动 Quota（根据记录文件 aquota.group）        |
|  -v  |                  显示启动服务过程的详细信息                  |

> 注意quotaon-auvg命令只需要在第一次启动Quota服务时才需要进行，因为下次重新启动系统时，系统的/etc/rc.d/rc,sysinit 初始化脚本会自动下达这个命令





【例 1】如果要同时启动针对用户和群组的 Quota 服务，可以使用如下命令：

```
[root@localhost ~]# quotaon -auvg
/dev/hda3 [/home]: group quotas turned on
/dev/hda3 [/home]: user quotas turned on
```



【例 2】如果只针对用户启动 /var 的 Quota 支持，可以使用如下命令：

```
[root@localhost ~]# quotaon -uv /var
```

***



## LVM逻辑卷管理机制（硬盘分区管理机制）



**LVM 是 Logical Volume Manager 的简称，译为中文就是逻辑卷管理。它是 Linux 下对硬盘分区的一种管理机制。**LVM 适合于管理大存储设备，并允许用户动态调整文件系统的大小。此外，LVM 的快照功能可以帮助我们快速备份数据。LVM 为我们提供了逻辑概念上的磁盘，使得文件系统不再关心底层物理磁盘的概念。==LVM 最大的好处就是可以随时调整分区的大小，分区中的现有数据不会丟失，并且不需要卸载分区、停止服务。==

> Linux LVM 允许我们在逻辑卷在线的状态下将其复制到另一设备上，此成功被称为快照功能。快照允许我们在复制的同时，保证运行关键任务的 Web 服务器或数据库服务继续工作。




***



LVM是在硬盘分区之上建立一个逻辑层，这个逻辑层让多个硬盘或分区看起来像一块逻辑硬盘，然后将这块逻辑硬盘分成逻辑卷之后使用，从而大大提高了分区的灵活性。我们把真实的物理硬盘或分区称作==物理卷==；==由多个物理卷组成一块大的逻辑硬盘,叫作卷组（VG）==；==将卷组划分成多个可以使用的分区，叫作逻辑卷（LV）==。而在LVM中的最小的存储单位不再是block，而是物理扩展块。



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202305162029683.png)



- 物理卷（Physical Volume，PV）：就是真正的物理硬盘或分区。
- 卷组（Volume Group，VG）：将多个物理卷合起来就组成了卷组。组成同一个卷组的物理卷可以是同一块硬盘的不同分区，也可以是不同硬盘上的不同分区。我们可以把卷组想象为一块逻辑硬盘。
- 逻辑卷（Logical Volume，LV）：卷组是一块逻辑硬盘，硬盘必须分区之后才能使用，我们把这个分区称作逻辑卷。逻辑卷可以被格式化和写入数据。我们可以把逻辑卷想象为分区。
- 物理扩展（Physical Extend，PE）：PE 是用来保存数据的最小单元，我们的数据实际上都是写入 PE 当中的。PE 的大小是可以配置的，默认是 4MB。

***



## PV 物理卷（创建、查看和删除）



> 建立所需的物理分区，创建方式就是使用fdisk交互命令。（注意：分区的系统ID不再是Linux默认的分区ID83，而要改成LVM的ID8e。）



#### 建立物理卷

建立物理卷的命令如下：

```
[root@localhost ~]# pvcreate [设备文件名]
```

*在建立物理卷是，既可以把整块硬盘都建立成物理卷也可以把某个分区建立成物理卷。*

```
[root@localhost ~]# pvcreate /dev/sdb
```



#### 查看物理卷

##### pvscan，查询系统中哪些硬盘或分区是物理卷

```
[root@localhost ~]# pvscan
```



##### pvdisplay 查看更详细的物理卷状态

```
[root@localhost ~]# pvdisplay
```



#### 删除物理卷

如果不再需要物理卷，则使用 pvremove 命令删除，命令如下：

```
[root@localhost ~]# pvremove /dev/sdb7
#当然,在我们的使中还要用到/dev/sdb7物理卷，所以实验完成后，记得把它再添加回来
```

> 在删除物理卷时，物理卷必须不属于任何卷组，也就是需要先将物理卷从卷组中删除，再删除物理卷。其实所有的删除就是把创建过程反过来，建立时不能少某个步骤，删除时也同样不能跳过某一步直接删除。

***



## VG卷组（创建、激活、查看、扩容、减小及删除）



#### 建立卷组

建立卷组使用的命令是 vgcreate，具体命令格式如下：

```
[root@localhost ~]# vgcreate [-s PE 大小] 卷组名 物理卷名
```

> [-s PE 大小] 选项的含义是指定 PE 的大小，单位可以是 MB、GB、TB 等。如果不写，则默认 PE 大小是 4MB。这里的卷组名指的就是要创建的卷组的名称，而物理卷名则指的是希望添加到此卷组的所有硬盘区分或者整个硬盘。



***

#### 激活卷组

**卷组创建完毕后，可以通过 vgchange 命令来激活卷组，而无法重启系统。**



vgchange 命令的基本格式如下：

```
#激活卷组
[root@localhost ~]# vgchange -a y 卷组名
#停用卷组
[root@localhost ~]# vachange -a n 卷组名
```

***



#### 查看卷组

查看卷组的命令同样有两个：

==vgscan 命令主要用于查看系统中**是否有卷组**==；==而 vgdisplay 命令则用于查看卷组的**详细状态**==。命令如下：

```
[root@1ocalhost ~]# vgscan
[root@localhost ~]# vgdisplay
```

***



#### 增加卷组容量

命令如下：

```
[root@localhost ~]# vgextend scvg /dev/sdb7
```



#### 减少卷组容量

既然可以增加卷组容量，当然也可以减少卷组容量，我们使用 **vgreduce 命令在卷组中删除物理卷**。命令如下：

```
[root@localhost ~]# vgreduce scvg /dev/sdb7
#在卷组中删除/dev/sdb7物理卷
[root@localhost ~]# vgreduce -a
#删除所有未使用的物理卷
```

***



#### 删除卷组

删除卷组的命令是 **vgremove**。命令如下：

```
[root@localhost ~]# vgremove scvg
Volume group "scvg" successfully removed
```

只有在删除卷组之后，才能删除物理卷。还要注意的是，scvg 卷组中还没有添加任何逻辑卷，如果拥有了逻辑卷，则记得先删除逻再删除卷组。==再次强调，删除就是安装的反过程，每一步都不能跳过。==



***



## LV逻辑卷（创建、查看、调整大小及删除）

**如何将卷组划分为逻辑卷？**



#### 建立逻辑卷

命令格式如下：

```
[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名
```

选项：

- -L容量：指定逻辑卷大小，单位为MB、GB、TB等
- -l个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量
- -n逻辑卷名：指定逻辑卷名。

> 建立完逻辑卷，还要再格式化和挂载之后才能正常使用。格式化和挂载命令与操作普通分区时是一样的。



***

#### 查看逻辑卷



##### lvscan只能看到系统中是否拥有逻辑卷

```
[root@localhost ~]# lvscan
```



##### lvdisplay可以看到逻辑卷的详细信息

```
[root@localhost ~]# lvdisplay
```



***



#### 调整逻辑卷大小

==一般不推荐减少逻辑卷空间，因为这非常容易导致逻辑卷中的文件系统数据丢失。除非我们已经备份了逻辑卷中的数据，否则不要减少逻辑卷的空间==



lvresize命令格式：

```
[root@localhost ~]# lvresize [选项] 逻辑卷的设备文件名
```

选项：

- -L 容量：安装容量调整大小，单位为 KB、GB、TB 等。使用 + 増加空间，- 代表减少空间。**如果直接写容量，则代表设定逻辑卷大小为指定大小**；
- -l 个数：按照 PE 个数调整逻辑卷大小；

> 我们执行完命令之后会发现，逻辑卷的分区大小还是原来的样子。**`刚刚只是逻辑卷的大小改变了，如果要让分区使用这个新逻辑卷，则还要使用resize2fs命令来调整分区的大小`**，不过这里就体现出了LVM的优势：（不需要卸载分区，直接就能调整大小）



**resize2fs**命令格式：

```
[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小]
```

选项：

- -f：强制调整；
- 设备文件名：指定调整哪个分区的大小；
- 调整的大小：指定把分区调整到多大，要加 M、G 等单位。如果不加大小，则会使用整个分区；

***



## 删除逻辑卷

**删除了逻辑卷，其中的数据就会丢失**，所以要确定你真的需要删除这个逻辑卷。

```
[root@localhost ~]#lvremove 逻辑卷的设备文件名
```

==删除前要先卸载==



***



## LVM（逻辑卷的管理）删除

***







## RAID（磁盘阵列）



### 简介

RAID（Redundant Arrays of Inexpensive Disks，磁盘阵列），翻译过来就是廉价的、具有冗余功能的磁盘阵列。**其原理是通过软件或硬件将多块较小的分区组合成一个容量较大的磁盘组。这个较大的磁盘组读写性能更好，更重要的是具有数据冗余功能。**





### RAID 0

==RAID 0 也叫 Stripe 或 Striping（带区卷），是 RAID 级别中存储性能最好的一个。==RAID 0 最好由相同容量的两块或两块以上的硬盘组成。如果组成RAID 0的两块硬盘大小不一致，则会影响RAID 0的性能。

***



这种模式下会先把硬盘分隔出大小相等的区块，当有数据需要写入硬盘时，会把数据也切割成相同大小的区块，然后分别写入各块硬盘。

**这样就相当于把一个文件分成几个部分同时向不同的硬盘中写入，数据的读/写速度当然就会非常快。**



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202305171255037.png)

> 解释一下这张示意图。我们准备了 3 块硬盘组成了 RAID 0，每块硬盘都划分了相等的区块。当有数据要写入 RAID 0 时，首先把数据按照区块大小进行分割，然后再把数据依次写入不同的硬盘。每块硬盘负责的数据写入量都是整体数据的 1/3，当然写入时间也只有原始时间的 1/3。所以，从理论上讲，由几块硬盘组成 RAID 0，数据的写入速度就是数据只写入一块硬盘速度的几倍。



==**RAID 0的优点**==:

- 通过把多块硬盘合并成一块大的逻辑硬盘，实现了数据跨硬盘存储
- 通过把数据分割成等大小的区块，分别存入不同的硬盘，加快了数据的读写速度。数据的读/写性能是几种RAID中最好的
- 多块硬盘合并成RAID 0，几块小硬盘组成了更大的容量的硬盘，而且没有容量损失，RAID 0的总容量就是几块硬盘的容量之和



> RAID 0有一个明显的缺点：**`没有数据冗余功能`**，RAID 0中的任何一块硬盘损坏，RAID中所有的数据都将丢失。==*由几块硬盘组成 RAID 0，数据的损毁概率就是只写入一块硬盘的几倍。*==

****



### RAID 1

**RAID 1也叫 Mirror 或 Mirroring（镜像卷），由两块硬盘组成。两块硬盘的大小最好一致，否则总容量以容量小的那块硬盘为主。**RAID 1 就具备了数据冗余功能，因为这种模式是把同一份数据同时写入两块硬盘。



比如有两块硬盘，组成了 RAID 1，当有数据写入时，相同的数据既写入硬盘 1，也写入硬盘 2。这样相当于给数据做了备份，所以任何一块硬盘损坏，数据都可以在另一块硬盘中找回。

<img src="https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202305171300828.png" alt="img" style="zoom:80%;" />



==RAID 1 具有了数据冗余功能，但是硬盘的容量却减少了 50%，==因为两块硬盘当中保存的数据是一样的，所以两块硬盘际上只保存了一块硬盘那么多的数据，这也是我们把 RAID 1 称作镜像卷的原因。



==**RAID 1的优点**==：

- 具备了数据冗余功能，任何一块硬盘出现故障，数据都不会丢失
- 数据的读取性能虽然不如RAID 0，但是比单一硬盘要好，因为数据有两份备份在不同的
