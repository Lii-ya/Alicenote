# 文件系统管理



[TOC]

















***





### 硬盘结构介绍


如果从存储数据的介质上来区分，硬盘可分为机械硬盘（Hard Disk Drive, HDD）和固态硬盘（Solid State Disk, SSD），机械硬盘采用磁性碟片来存储数据，而固态硬盘通过闪存颗粒来存储数据。



#### 什么是机械硬盘（HDD）？





![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201558706.png)



> 机械硬盘主要由磁盘盘片、磁头、主轴与传动轴等组成，数据就存放在磁盘盘片中。留声机上使用的唱片和我们的磁盘盘片非常相似，只不过留声机只有一个磁头，而硬盘是上下双磁头，盘片在两个磁头中间高速旋转。

> 机械硬盘是上下盘面同时进数据读取的。而且机械硬盘的旋转速度要远高于唱片（目前机械硬盘的常见转速是 7200 r/min），所以机械硬盘在读取或写入数据时，非常害怕晃动和磕碰。另外，因为机械硬盘的超高转速，如果内部有灰尘，则会造成磁头或盘片的损坏，所以机械硬盘内部是封闭的，如果不是在无尘环境下，则禁止拆开机械硬盘。



##### 机械硬盘的逻辑结构



机械硬盘的逻辑结构主要分为磁道、扇区和拄面。



<img src="https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201600061.png" alt="img" style="zoom:80%;" />



**什么是磁道？**

每个盘片都在逻辑上有很多的同心圆，最外面的同心圆就是 0 磁道。我们将每个同心圆称作磁道（注意，磁道只是逻辑结构，在盘面上并没有真正的同心圆）。硬盘的磁道密度非常高，通常一面上就有上千个磁道。但是相邻的磁道之间并不是紧挨着的，这是因为磁化单元相隔太近会相互产生影响。



**扇区是什么？**

扇区其实是很形象的，大家都见过折叠的纸扇吧，纸扇打开后是半圆形或扇形的，不过这个扇形是由每个扇骨组合形成的。在磁盘上每个同心圆是磁道，从圆心向外呈放射状地产生分割线（扇骨），将每个磁道等分为若干弧段，每个弧段就是一个扇区。每个扇区的大小是固定的，为 512Byte。扇区也是磁盘的最小存储单位。



**柱面是什么？**

如果硬盘是由多个盘片组成的，每个盘面都被划分为数目相等的磁道，那么所有盘片都会从外向内进行磁道编号，最外侧的就是 0 磁道。具有相同编号的磁道会形成一个圆柱，这个圆柱就被称作磁盘的柱面。

![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201600926.png)

***



> 硬盘的大小是使用**"磁头数 x 柱面数 x 扇区数 x 每个扇区的大小"这样的公式来计算的**。其中，磁头数（Heads）表示硬盘共有几个磁头，也可以理解为硬盘有几个盘面，然后乘以 2；柱面数（Cylinders）表示硬盘每面盘片有几条磁道；扇区数（Sectors）表示每条磁道上有几个扇区；每个扇区的大小一般是 512Byte。



**硬盘的接口**

- IDE 硬盘接口（Integrated Drive Eectronics，并口，即电子集成驱动器）也称作 "ATA硬盘" 或 "PATA硬盘"，是早期机械硬盘的主要接口，ATA133 硬盘的理论速度可以达到 133MB/s（此速度为理论平均值）
- SATA 接口（Serial ATA，串口），是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是 SATA 三代，理论传输速度达到 600MB/s（此速度为理论平均值）
- SCSI 接口（Small Computer System Interface，小型计算机系统接口），广泛应用在服务器上，具有应用范围广、多任务、带宽大、CPU 占用率低及热插拔等优点，理论传输速度达到 320MB/s



***



#### 固态硬盘（SSD）


固态硬盘和传统的机械硬盘最大的区别就是不再采用盘片进行数据存储，而采用存储芯片进行数据存储。固态硬盘的存储芯片主要分为两种：**一种是采用闪存作为存储介质的；另一种是采用DRAM作为存储介质的**。目前使用较多的主要是采用闪存作为存储介质的固态硬盘.



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201607202.png)




​                                                                                             表 1 固态硬盘和机械硬盘对比

| 对比项目  |    固态硬盘     | 机械硬盘 |
| :-------: | :-------------: | :------: |
|   容量    |      较小       |    大    |
| 读/写速度 |      极快       |   —般    |
| 写入次数  | 5000〜100000 次 | 没有限制 |
| 工作噪声  |      极低       |    有    |
| 工作温度  |      极低       |   较高   |
|   防震    |      很好       |  怕震动  |
|   重量    |       低        |    高    |
|   价格    |       高        |    低    |



***



### 文件系统



通常情况下，文件系统会将文件的实际内容和属性分开存放：

- 文件的属性保存在 inode 中（i 节点）中，每个 inode 都有自己的编号。每个文件各占用一个 inode。不仅如此，inode 中还记录着文件数据所在 block 块的编号；
- 文件的实际内容保存在 block 中（数据块），类似衣柜的隔断，用来真正保存衣物。每个 block 都有属于自己的编号。当文件太大时，可能会占用多个 block 块。
- 另外，还有一个 super block（超级块）用于记录整个文件系统的整体信息，包括 inode 和 block 的总量、已经使用量和剩余量，以及文件系统的格式和相关信息等。



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201619396.png)

> 图 中，文件系统先格式化出 inode 和 block 块，假设某文件的权限和属性信息存放到 inode 4 号位置，这个 inode 记录了实际存储文件数据的 block 号有 4 个，分别为 2、7、13、15，由此，操作系统就能快速地找到文件数据的存储位置。



**这种管理文件的系统称为索引式文件系统，Linux 文件系统（Ext 系列）就属于索引式文件系统。**



> 注意，**inode 节点并不存储文件的文件名**，因为文件名是文件所在目录的数据，所以会保存在上一级目录的 block 块中。前面章节在讲权限命令的时候说过，要对文件的上一级目录拥有 w 权限，才能删除目录中的文件，就是因为文件名是保存在目录的 block 中的。

***



## Linux系统如何识别硬盘设备和硬盘区分的

MBR，全称 Master Boot Record，可译为**硬盘主引导记录**，占据硬盘 0 磁道的第一个扇区。MBR 中，包括用来载入操作系统的可执行代码，实际上，此可执行代码就是 MBR 中前 446 个字节的 boot loader 程序（引导加载程序），而在 boot loader 程序之后的 64 个（16×4）字节的空间，就是存储的分区表（Partition table）相关信息。



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201628046.png)



在分区表中，主要存储的值息包括分区号、分区的起始磁柱数量。Linux操作系统在初始化时就可以根据分区表中以上3种信息来识别硬盘设备。

常见的分区号如下：

- 0x5（或 0xf）：可扩展分区（Extended partition）。
- 0x82：Linux 交换区（Swap partition）。
- 0x83：普通 Linux 分区（Linux partition）。
- 0x8e：Linux 逻辑卷管理分区（Linux LVM partition）。
- 0xfd：Linux 的 RAID 分区（Linux RAID auto partition）。

***



由于MBR留给分区表的磁盘空间只有64个字节，而每个分区表的大小为16个字节，所以在一个硬盘上最多可以划分出4个主分区。

不过，在 Linux 的 Kernel 中所支持的分区数量有如下限制：

- 一个 IDE 的硬盘最多可以使用 63 个分区；
- 一个 SCSI 的硬盘最多可以使用 15 个分区。

***



**硬盘分区的原因：**

1. 方便管理和控制
2. 提高系统的效率
3. 使用磁盘配额的功能限制用户使用的磁盘量
4. 便于备份和恢复

***



## df命令：查看文件系统硬盘使用情况


**df 命令，用于显示 Linux 系统中各文件系统的硬盘使用情况，包括文件系统所在硬盘分区的总容量、已使用的容量、剩余容量等。**

> df 命令主要是从各文件系统的 Super block 中读取数据。



**命令格式：**

```
[root@localhost ~]# df [选项] [目录或文件名]

```

| 选项 |                             作用                             |
| :--: | :----------------------------------------------------------: |
|  -a  | 显示所有文件系统信息，包括系统特有的 /proc、/sysfs 等文件系统； |
|  -m  |                    以 MB 为单位显示容量；                    |
|  -k  |           以 KB 为单位显示容量，默认以 KB 为单位；           |
|  -h  |       使用人们习惯的 KB、MB 或 GB 等单位自行显示容量；       |
|  -T  |                  显示该分区的文件系统名称；                  |
|  -i  |      不用硬盘容量显示，而是以含有 inode 的数量来显示。       |



【例1】

```
[root@localhost ~]# df
Filesystem      1K-blocks      Used Available Use% Mounted on
/dev/hdc2         9920624   3823112   5585444  41% /
/dev/hdc3         4956316    141376   4559108   4% /home
/dev/hdc1          101086     11126     84741  12% /boot
tmpfs              371332         0    371332   0% /dev/shm
```

> 不使用任何选项的 df 命令，默认会将系统内所有的文件系统信息，以 KB 为单位显示出来。



本例中，由 df 命令显示出的各列信息的含义分别是：

- Filesystem：表示该文件系统位于哪个分区，因此该列显示的是设备名称；
- 1K-blocks：此列表示文件系统的总大小，默认以 KB 为单位；
- Used：表示用掉的硬盘空间大小；
- Available：表示剩余的硬盘空间大小；
- Use%：硬盘空间使用率。如果使用率高达 90% 以上，就需要额外注意，因为容量不足，会严重影响系统的正常运行；
- Mounted on：文件系统的挂载点，也就是硬盘挂载的目录位置。

***



## du命令：统计目录或文件所占磁盘空间大小



**du命令的格式：**

```
[root@localhost ~]# du [选项] [目录或文件名]
```

选项：

- -a：显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量
- -h：使用习惯单位显示磁盘占用量，如 KB、MB 或 GB 等；
- -s：统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量



***



### du命令和df命令的区别

使用du命令和df命令去统计分区的使用情况，得到的数据是不一样的。那是因为df命令是从文件系统的角度考虑的，**在使用df命令统计分区时，不仅要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但程序并没有释放空间）**。而du命令是**面向文件**的，**只会计算文件或目录占用的磁盘空间**。也就是说，==df 命令统计的分区更准确，是真正的空闲空间。==

***



## mount命令：挂载Linux系统外的文件


**挂载指的是将硬件设备的文件系统和 Linux 系统中的文件系统，通过指定目录（作为挂载点）进行关联。而要将文件系统挂载到 Linux 系统上，就需要使用 mount 挂载命令。**



**mount 命令的常用格式有以下几种：**

```
[root@localhost ~]# mount [-l]
```

> 单纯使用 mount 命令，会显示出系统中已挂载的设备信息，使用 -l 选项，会额外显示出卷标名称（读者可自行运行，查看输出结果）；



```
[root@localhost ~]# mount -a
```

> -a 选项的含义是自动检查 /etc/fstab 文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。这里简单介绍一下 /etc/fstab 文件，此文件是自动挂载文件，系统开机时会主动读取 /etc/fstab 这个文件中的内容，根据该文件的配置，系统会自动挂载指定设备。



```
[root@localhost ~]# mount [-t 系统类型] [-L 卷标名] [-o 特殊选项] [-n] 设备文件名 挂载点
```

各选项的含义分别是：

- -t 系统类型：**指定欲挂载的文件系统类型**。Linux 常见的支持类型有 EXT2、EXT3、EXT4、iso9660（光盘格式）、vfat、reiserfs 等。如果不指定具体类型，挂载时 Linux 会自动检测。
- -L 卷标名：除了使用设备文件名（例如 /dev/hdc6）之外，还可以利用文件系统的卷标名称进行挂载。
- -n：在默认情况下，系统会将实际挂载的情况实时写入 /etc/mtab 文件中，但在某些场景下（例如单人维护模式），为了避免出现问题，会刻意不写入，此时就需要使用这个选项；
- -o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定，则使用默认值（defaults）。



​                                                                                            mount命令选项及功能

|    选项     |                             功能                             |
| :---------: | :----------------------------------------------------------: |
|    rw/ro    | 是否对挂载的文件系统拥有读写权限，rw 为默认值，表示拥有读写权限；ro 表示只读权限。 |
| async/sync  | 此文件系统是否使用同步写入（sync）或异步（async）的内存机制，默认为异步 async。 |
|  dev/nodev  | 是否允许从该文件系统的 block 文件中提取数据，为了保证数据安装，默认是 nodev。 |
| auto/noauto | 是否允许此文件系统被以 mount -a 的方式进行自动挂载，默认是 auto。 |
| suid/nosuid |   设定文件系统是否拥有 SetUID 和 SetGID 权限，默认是拥有。   |
| exec/noexec |     设定在文件系统中是否允许执行可执行文件，默认是允许。     |
| user/nouser | 设定此文件系统是否允许让普通用户使用 mount 执行实现挂载，默认是不允许（nouser），仅有 root 可以。 |
|  defaults   | 定义默认值，相当于 rw、suid、dev、exec、auto、nouser、async 这 7 个选项。 |
|   remount   |     重新挂载已挂载的文件系统，一般用于指定修改特殊权限。     |



## Linux系统挂载光盘



将光盘放入光驱之后，需要执行如下挂载命令：

```
[root@localhost ~]# mkdir/mnt/cdrom/
#建立挂载点
[root@localhost ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom/
#挂载光盘
```


光盘的文件系统是 iso9660，不过这个文件系统可以省略不写，系统会自动检测。因此，挂在命令也可以写为如下的方式：

```
[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/
#挂载光盘。两个挂载光盘的命令使用一个就可以了
[root@localhost ~]# mount
#查看已经挂载的设备
…省略部分输出…
/dev/srO on /mnt/cdrom type iso9660 (ro)
#光盘已经挂载了，但是挂载的设备文件名是/dev/sr0
```


/dev/cdrom 只是一个软链接（如同 Windows 系统中的文件快捷方式）。 命令如下：

```
[root@localhost ~]#ll /dev/cdrom
lrwxrwxrwx 1 root root 3 1月31 01:13/dev/cdrom ->sr0
```


/dev/cdrom 的源文件是 /dev/sr0。/dev/sr0 是光驱的真正设备文件名，代表 SCSI 接口或 SATA 接口的光驱，所以刚刚查询挂载时看到的光驱设备文件命令是 /dev/sr0。也就是说，挂载命令也可以写成这样：

```
[root@localhost ~]# mount /dev/sr0 /mnt/cdrom/
```


其实光驱的真正设备文件名是保存在 /proc/sys/dev/cdrom/info 文件中的，所以可以通过查看这个文件来查询光盘的真正设备文件名，命令如下：

```
[root@localhost ~]# cat /proc/sys/dev/cdrom/info
CD-ROM information, ld: cdrom.c 3.20 2003/12/17
drive name: sr0
…省略部分输出…
```



## Linux系统挂载U盘



**查看到 U 盘的设备文件名，接下来就要创建挂载点了。命令如下：**

```
[root@localhost ~]# mkdir /mnt/usb
```

**挂载命令如下：**

```
[root@localhost ~]# mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/
#挂载U盘，指定中文编码格式为UTF-8
```

如果没有指定中文编码格式，会输出乱码。出现乱码的原因是因为 U 盘是 Windows 中保存的数据，而 Windows 中的中文编码格式和 Linux 中的不一致。

***



## Linux开机自动挂载硬件设备（配置/etc/fastab文件）



Linux通过/etc/fstab配置文件来确定哪些分区需要挂载。这个配置文件对所有用户可读，但只有root用户有权限修改文件。



【例1】

```
[root@localhost ~]# vi /etc/fstab
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1
UUID=0b23d315-33a7-48a4-bd37-9248e5c44345 /boot ext4 defaults 1 2
UUID=4021be19-2751-4dd2-98cc-383368c39edb swap swap defaults 0 0
#只有这三个是真正的硬盘分区，下面的都是虚拟文件系统或交换分区
tmpfs /dev/shm tmpfs defaults 0 0
devpts /dev/pts devpts gid=5, mode=620 0 0
sysfs /sys sysfe defaults 0 0
proc /proc proc defaults 0 0
```

>  tmpfs、devpts、sysfs 和 proc 这几行，它们分别是与共享内存、终端窗口、设备信息和内核参数相关联的特殊设备。



**在 fstab 文件中，每行数据都分为了 6 个字段，它们的含义分别是：**

1. 用来挂载每个文件系统的分区设备文件名或 UUID（用于指代设备名）；
2. 挂载点；
3. 文件系统的类型；
4. 各种挂载参数；
5. 指定分区是否被 dump 备份；
6. 指定分区是否被 fsck 检测；

***



### /etc/fstab文字各字段的含义



**什么是UUID？**

UUID 即通用唯一标识符，是一个 128 位比特的数字，可以理解为就是硬盘的 ID，UUID 由系统自动生成和管理。



可以用以下三个命令来查找UUID

```
[root@localhost ~]# dumpe2fs /dev/sdb5

[root@localhost ~]# ls -l /dev/disk/by-uuid/

 blkid 命令查看所有磁盘分区的 UUID
```



**第三字段**

文件系统名称，CentOS 6.3 的默认文件系统应该是 ext4。


**第四字段**

挂载参数，这个参数和 mount 命令的挂载参数一致。


**第五字段**

表示“指定分区是否被 dump 备份”，0 代表不备份，1 代表备份，2 代表不定期备份。


**第六字段**

表示“指定分区是否被 fsck 检测”，0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般分区的优先级是 1，其他分区的优先级是 2。



***



### 修改配置文件后导致出错如何解决



提示是没有写权限，那么只要把 / 分区重新挂载上读写权限不就可以修改了吗？命令如下：

```
[root@localhost ~]#mount-oremount, rw/
```



***



## umount命令：卸载文件系统


**需要先将其与挂载点取消关联，然后才能成功卸载**


umount 命令用于卸载已经挂载的硬件设备，该命令的基本格式如下：

```
[root@localhost ~]# umount 设备文件名或挂载点
```

==注意，卸载命令后面既可以加设备文件名，也可以加挂载点，不过只能二选一==



***



## fsck命令：检测和修复文件系统



**fsck 命令用于检查文件系统并尝试修复出现的错误**。

该命令的基本格式如下：

```
[root@localhost ~]# fsck [选项] 分区设备文件名
```


​                                                                                    表 1 fsck命令常用选项及其功能

|      选项       |                             功能                             |
| :-------------: | :----------------------------------------------------------: |
|       -a        |             自动修复文件系统，没有任何提示信息。             |
|       -r        | 采取互动的修复模式，在修改文件前会进行询问，让用户得以确认并决定处理方式。 |
|   -A（大写）    | 按照 /etc/fstab 配置文件的内容，检查文件内罗列的全部文件系统。 |
| -t 文件系统类型 |                  指定要检查的文件系统类型。                  |
|   -C（大写）    |                    显示检查分区的进度条。                    |
|       -f        | 强制检测，一般 fsck 命令如果没有发现分区有问题，则是不会检测的。如果强制检测，那么不管是否发现问题，都会检测。 |
|       -y        |    自动修复，和 -a 作用一致，不过有些文件系统只支持 -y。     |



> ==使用 fsck 检查并修复文件系统是存在风险的，特别是当硬盘错误非常严重的时候，因此，当一个受损文件系统中包含了非常有价值的数据时，务必首先进行备份！==



【例1】

如果想要修复某个分区，则只需执行如下命令：

```
[root@localhost ~]#fsck -r /dev/sdb1
#采用互动的修复模式
```

> fsck 命令在执行时，如果发现存在没有文件系统依赖的文件或目录，就会提示用户是否把它们找回来，因为这些没有文件系统依赖的文件或目录对用户来说是看不到的，换句话说，用户根本无法使用，这通常是由文件系统内部结构损坏导致的。如果用户同意找回（输入 y），fsck 命令就会把这些孤立的文件或目录放到 lost+found 目录中，并用这些文件自己对应的 inode 号来命名，以便用户查找自己丢失的文件。



***



## dumpe2fs命令：查看文件系统信息



**使用 dumpe2fs 命令来查看文件系统的详细信息**

此命令的基本格式如下：

```
[root@www ~]# dumpe2fs [-h] 文件名
```

> **-h 选项的含义是仅列出 superblock（超级块）的数据信息**





## fdisk命令：给硬盘分区

 

命令格式：

```
[root@localhost ~]# fdisk ~l
#列出系统分区
[root@localhost ~]# fdisk 设备文件名
#给硬盘分区
```

==注意，千万不要在当前的硬盘上尝试使用 fdisk，这会完整删除整个系统，一定要再找一块硬盘，或者使用虚拟机。==

> 使用 "fdisk -l" 查看分区信息，能够看到我们添加的硬盘的信息。


​                                                                                                       

​                                                                                                     表 1 fdisk 交互

| 命令 |                            说 明                             |
| :--: | :----------------------------------------------------------: |
|  a   |                        设置可引导标记                        |
|  b   |                      编辑 bsd 磁盘标签                       |
|  c   |                  设置 DOS 操作系统兼容标记                   |
|  d   |                         删除一个分区                         |
|  1   | 显示已知的文件系统类型。82 为 Linux swap 分区，83 为 Linux 分区 |
|  m   |                         显示帮助菜单                         |
|  n   |                           新建分区                           |
|  0   |                     建立空白 DOS 分区表                      |
|  P   |                         显示分区列表                         |
|  q   |                          不保存退出                          |
|  s   |                    新建空白 SUN 磁盘标签                     |
|  t   |                    改变一个分区的系统 ID                     |
|  u   |                       改变显示记录单位                       |
|  V   |                          验证分区表                          |
|  w   |                           保存退出                           |
|  X   |                      附加功能（仅专家）                      |





## fdisk创建分区的过程



> 在第一个扇区中，主引导记录需要占用446字节，分区表占用64字节，还有2个字节供结束符使用。而分区表是本节所关心的，在分区表中，每记录一个分区信息就需要占用16字节，这样一来，整个分区表最多只能记录4个分区信息，这4个分区就称为4个主分区。



<img src="https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202305110907045.png" alt="img" style="zoom:80%;" />

*为了解决分区个数不够的问题，还可以进一步将第一个扇区的分区表中 16 个字节（原本要写入主分区信息）的空间，用来存储另外一个分区的信息，通常将这 16 个字节的空间称为扩展分区。*

**注意，扩展分区并不是一个真正的分区，而可以看做是一个占用 16 字节分区表空间的指针，它用来指向另一个分区。**

***



通常情况下，用户会选择使用 3 个主分区外加 1 个扩展分区的方法，然后在扩展分区中再创建出多个逻辑分区，从而来满足多分区（大于 4 个）的需求

<img src="https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202305110907604.png" alt="img" style="zoom:80%;" />


因此总的来说，硬盘分区有 3 种，分别是==主分区、扩展分区和逻辑分区==。对于一个硬盘来说，主分区至少有 1 个，最多有 4 个；扩展分区可以没有，最多只能有 1 个，且主分区+扩展分区总共不能超过 4 个；逻辑分区可以有若干个。

***



#### partprobe 命令

**这个命令的作用是让系统内核重新读取分区表信息**

```
[root@localhost ~]# partprobe
```

***



## parted命令：创建分区


==parted 命令是可以在命令行直接分区和格式化的==，不过 parted 交互模式才是更加常用的命令方式，进入交互模式的方法如下：

```
[root@localhost ~]# parted 硬盘设备文件名
#进入交互模式
```


​                                                                                          表 1 parted常见的交互命令

|             parted交互命令              |                  说 明                   |
| :-------------------------------------: | :--------------------------------------: |
|              check NUMBER               |         做一次简单的文件系统检测         |
| cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER  |         复制文件系统到另一个分区         |
|             help [COMMAND]              |            显示所有的命令帮助            |
|       mklabel,mktable LABEL-TYPE        |        创建新的磁盘卷标（分区表）        |
|           mkfs NUMBER FS-TYPE           |           在分区上建立文件系统           |
|  mkpart PART-TYPE [FS-TYPE] START END   |               创建一个分区               |
|  mkpartfs PART-TYPE FS-TYPE START END   |         创建分区，并建立文件系统         |
|          move NUMBER START END          |                 移动分区                 |
|            name NUMBER NAME             |                给分区命名                |
| print [devices\|free\|list,all\|NUMBER] | 显示分区表、活动设备、空闲空间、所有分区 |
|                  quit                   |                   退出                   |
|            rescue START END             |              修复丢失的分区              |
|         resize NUMBER START END         |               修改分区大小               |
|                rm NUMBER                |                 删除分区                 |
|              select DEVICE              |            选择需要编辑的设备            |
|          set NUMBER FLAG STATE          |               改变分区标记               |
|         toggle [NUMBER [FLAG]]          |             切换分区表的状态             |
|                unit UNIT                |              设置默认的单位              |
|                 Version                 |                 显示版本                 |

***



**使用 print 命令可以査看分区表信息，包括硬盘参数、硬盘大小、扇区大小、分区表类型和分区信息。**

**分区信息共有 7 列：**

1. Number：分区号，比如，1号就代表 /dec/sdb1；
2. Start：分区起始位置。这里不再像 fdisk 那样用柱面表示，使用字节表示更加直观；
3. End：分区结束位置；
4. Size：分区大小；
5. Type：分区类型，有 primary、extended、logical 等类型；
6. Filesystem：文件系统类型；
7. 标志：分区的标记。

***



## mkfs命令：格式化分区（为分区写入文件系统）

> 分区完后，**如果不格式化写入文件系统，则是不能正常使用的**。这时需要使用mkfs命令对硬盘分区进行格式化

mkfs 命令格式如下：

```
[root@localhost ~]# mkfs [-t 文件系统格式] 分区设备文件名
```

**-t 文件系统格式：用于指定格式化的文件系统，如 ext3、ext4；**



***



## mke2fs命令：格式化硬盘（给硬盘写入文件系统）



**mke2fs 命令的基本格式如下：**

```
[root@localhost ~]# mke2fs [选项] 分区设备文件名
```


​                                                                                    表 1 mke2fs命令常用选项及功能

|    选项     |                          功能                           |
| :---------: | :-----------------------------------------------------: |
| -t 文件系统 |    指定格式化成哪个文件系统， 如 ext2、ext3、ext4；     |
|   -b 字节   |                   指定 block 的大小；                   |
|   -i 字节   | 指定"字节 inode "的比例，也就是多少字节分配一个 inode； |
|     -j      |           建立带有 ext3 日志功能的文件系统；            |
|  -L 卷标名  |   给文件系统设置卷标名，就不使用 e2label 命令设定了；   |



***



## 虚拟内存和物理内存



**物理内存**

就是系统硬件提供的内存大小，是真正的内存。



**虚拟内存**

是为了满足物理内存的不足而提出来的策略，它是利用磁盘空间虚拟出一块逻辑内存。==用作虚拟内存的磁盘空间被称为交换空间（swap空间）==



> 作为物理内存的扩展，Linux会在物理内存不足时，使用交换分区的虚拟内存，更详细地说，就是内核会将暂时不用地内存块信息写到交换空间，这样一来，物理内存得到了释放，这块内存就可以用于其他目的，当需要用到原始地内容时，这些信息会被重新从交换空间读入物理内存。

***



## 如何建立交换分区（swap分区）



*swap分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。*



**使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。**

***

> 建立新的 swap 分区，只需要执行以下几个步骤：
>
> 1. 分区：不管是 fdisk 命令还是 parted 命令，都需要先区。
> 2. 格式化：格式化命令稍有不同，使用 mkswap 命令把分区格式化成 swap 分区。
> 3. 使用 swap 分区。



### 使用swap分区

```
[root@localhost ~]#free
total used free shared buffers cached
Mem: 1030796 130792 900004 0 15292 55420
-/+ buffers/cache: 60080 970716
Swap: 2047992 0 2047992
```



#### free命令

free 命令主要是用来查看内存和 swap 分区的使用情况的，其中：

- total：是指总数；
- used：是指已经使用的；
- free：是指空闲的；
- shared：是指共享的；
- buffers：是指缓冲内存数；
- cached：是指缓存内存数，单位是KB；

>  buffers（缓冲）和 cached（缓存）的区别：
>
> 简单来讲，==**cached 是给读取数据时加速的**，**buffers 是给写入数据加速的**。==cached 是指把读取出来的数据保存在内存中，当再次读取时，不用读取硬盘而直接从内存中读取，加速了数据的读取过程；buffers 是指在写入数据时，先把分散的写入操作保存到内存中，当达到一定程度后再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。

***

