# Linux权限管理



[TOC]





***









## chgrp命令：修改文件和目录的所属组


基本格式：

```
[root@localhost ~]# chgrp [-R] 所属组 文件名（目录名）
```

**-R（注意是大写）选项长作用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息。**

>
> 使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示 "invaild group name"。



## chown命令：修改文件和目录的所有者和所属组

> 这个命令也可以修改文件（或目录）的所属组。



基本格式：

```
[root@localhost ~]# chown [-R] 所有者 文件或目录
```

**-R（注意大写）选项表示连同子目录中的所有文件，都更改所有者。**



如果需要同时更改所有者和所属组，chown 命令的基本格式为：

```
[root@localhost ~]# chown [-R] 所有者:所属组 文件或目录
```

>
> 注意，在 chown命令中，所有者和所属组中间也可以使用点“.”，但是会出现一个问题，如果用户在设定账号时加入了小数点，就会造成系统误判。因此，建议使用==冒号“  ：”连接所有者和所属组==

> 使用 chown 命令修改文件或目录的所有者（或所属者）时，要保证使用者用户（或用户组）存在，否则该命令无法正确执行，会提示 "invalid user" 或者 "invaild group"。



***



## 权限位


Linux 系统，最常见的文件权限有 3 种，即对文件的读（用 r 表示）、写（用 w 表示）和执行（用 x 表示，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过 ls 命令即可看到。

> 除此之外， s（针对可执行文件或目录，使文件在执行阶段，临时拥有文件所有者的权限）和 t（针对目录，任何用户都可以在此目录中创建文件，但只能删除自己的文件），文件设置 s 和 t 权限，会占用 x 权限的位置。





每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管。

为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符

![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304131932312.png)



### 读写执行权限（-r、-w、-x）的真正含义是什么？



#### rwx 权限对文件的作用

|   rwx 权限    |                         对文件的作用                         |
| :-----------: | :----------------------------------------------------------: |
|  读权限（r）  | 表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。 |
|  写权限（w）  | 表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。 |
| 执行权限（x） | 表示该文件具有被系统执行的权限。Window系统中查看一个文件是否为可执行文件，是通过扩展名（.exe、.bat 等），但在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。 |



#### rwx 权限对目录的作用

|   rwx 权限    |                         对目录的作用                         |
| :-----------: | :----------------------------------------------------------: |
|  读权限（r）  | 表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容。 |
|  写权限（w）  | 对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：①在此目录中建立新的文件或子目录；②删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；③对已存在的文件或目录做更名操作；④移动此目录下的文件和目录的位置。一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令。 |
| 执行权限（x） | 目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，赋予 x 权限的用户或群组可以使用 cd 命令。 |

>
> 对目录来说，**如果只赋予 r 权限，则此目录是无法使用的**。很简单，只有 r 权限的目录，用户只能查看目录结构，根本无法进入目录（需要用 x 权限），更不用说使用了。
>
> 因此，对于目录来说，常用来设定目录的权限其实只有 0（---）、5（r-x）、7（rwx）这 3 种。



***



## chomd命令：修改文件或目录的权限



**chmod 命令设定文件权限的方式有 2 种，分别可以使用数字或者符号来进行权限的变更。**



### chmod命令使用数字修改文件权限


Linux系统中，文件的基本权限又9个字符组成，以 rwxrw-r-x 为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：

```
r --> 4
w --> 2
x --> 1
```

==由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。==



【1】拿 rwxrw-r-x 来说，所有者、所属组和其他人分别对应的权限值为：

```
所有者 = rwx = 4+2+1 = 7
所属组 = rw- = 4+2 = 6
其他人 = r-x = 4+1 = 5

此权限对应的权限值就是 765
```



使用数字修改文件权限的 chmod 命令基本格式为：

```
[root@localhost ~]# chmod [-R] 权限值 文件名
```

**-R（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。**

***



### chmod命令使用字母修改文件权限


既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（rwx），**chmod 命令中用 u、g、o 分别代表 3 种身份，还用 a 表示全部的身份（all 的缩写）**。另外，chmod 命令仍使用 r、w、x 分别表示读、写、执行权限。


使用字母修改文件权限的 chmod 命令，其基本格式如图 1 所示。

![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304131956884.png)



【1】例如，如果我们要设定 .bashrc 文件的权限为 rwxr-xr-x，则可执行如下命令：

```
[root@localhost ~]# chmod u=rwx,go=rx .bashrc
[root@localhost ~]# ls -al .bashrc
-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc
```

***



## umask详解：令新建文件和目录拥有默认权限



直接使用umask命令可以获得默认umask默认权限的值。

```
[root@localhost ~]# umask
0022
#root用户默认是0022，普通用户默认是 0002
```

> 
>
>  umask 默认权限确实由**4 个八进制数组成。**
>
> 第一个数字代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT），这里只做了解。后三位“022”，将其转化为字母形式： ----w--w-
>
> 虽然 umask 默认权限是用来设定文件或目录的初始权限，但并不是直接将 umask 默认权限作为文件或目录的初始权限，还要对其进行 "再加工"。



**文件和目录的真正初始权限，可通过以下的计算得到：**

```
文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限
```



在 Linux 系统中，文件和目录的最大默认权限是不一样的：

- 对文件来讲，其可拥有的最大默认权限是 666，即 rw-rw-rw-。也就是说，使用文件的任何用户都没有执行（x）权限。原因很简单，执行权限是文件的最高权限，赋予时绝对要慎重，因此绝不能在新建文件的时候就默认赋予，只能通过用户手工赋予。
- 对目录来讲，其可拥有的最大默认权限是 777，即 rwxrwxrwx。



#### 计算

我们利用字母权限的方式计算文件或目录的初始权限。以 umask 值为 022 为例，分别计算新建文件和目录的初始权限：

- 文件的最大默认权限是 666，换算成字母就是 "-rw-rw-rw-"，umask 的值是 022，换算成字母为 "-----w--w-"。把两个字母权限相减，**得到 (-rw-rw-rw-) - (-----w--w-) = (-rw-r--r--)**，这就是新建文件的初始权限。

- 目录的默认权限最大可以是 777，换算成字母就是 "drwxrwxrwx"，umask 的值是 022，也就是 "-----w--w-"。把两个字母权限相减，得到的就是新建目录的默认权限，**即 (drwxrwxrwx) - (-----w--w-) = (drwxr-xr-x)。**



> 注意，==在计算文件或目录的初始权限时，不能直接使用最大默认权限和 umask 权限的数字形式做减法，这是不对的==。例如，若 umask 默认权限的值为 033，按照数字形式计算文件的初始权限，666-033=633，但我们按照字母的形式计算会得到 （rw-rw-rw-) - (----wx-wx) = (rw-r--r--)，换算成数字形式是 644。

> 这里的减法，其实是“遮盖”的意思，也就是说，最大默认权限中和 umask 权限公共的部分，通过减法运算会被遮盖掉，最终剩下的“最大默认权限”，才是最终赋予文件或目录的初始权限。



### umask默认权限修改方法



#### ①直接修改

【例】

```
[root@localhost ~]# umask 002
[root@localhost ~]# umask
0002
[root@localhost ~]# umask 033
[root@localhost ~]# umask
0033
```

**这种方式修改的 umask 只是临时有效，一旦重启或重新登陆系统，就会失效。**



#### ②永久修改

则需要修改对应的==环境变量配置文件 /etc/profile==

【例】

```
[root@localhost ~]# vim /etc/profile
...省略部分内容...
if [ $UID -gt 199]&&[ "'id -gn'" = "'id -un'" ]; then
    umask 002
    #如果UID大于199（普通用户），则使用此umask值
else
    umask 022
    #如果UID小于199（超级用户），则使用此umask值
fi
…省略部分内容…
```



***



# ACL访问控制权限

> 
>
> 权限前的字符，表示文件的具体类型，比如 d 表示目录，- 表示普通文件，l 表示连接文件，b 表示设备文件，等等。



以上3种身份是不够用的，看下面的图来举个例子

![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304190905145.png)

当组里又外来一个st学员时，无法将此外加入的学员进行分配，因为我们只想让他拥有r-x的权限。若让在任意一个用户组底下不经不符合要求也可能需要改动原本的权限。



#### ACL

ACL，是 Access Control List（访问控制列表）的缩写，在 Linux 系统中， ACL 可实现对单一用户设定访问文件的权限。也可以这么说，设定文件的访问权限，除了用传统方式（3 种身份搭配 3 种权限），还可以使用 ACL 进行设定。拿本例中的 st 学员来说，既然赋予它传统的 3 种身份，无法解决问题，就可以考虑使用 ACL 权限控制的方式，直接对 st 用户设定访问文件的 r-x 权限。



***



### 开启ACL权限

CentOS 6.x 系统中，ACL 权限默认处于开启状态，无需手工开启。但如果你的操作系统不是 CentOS 6.x，可以通过如下方式查看ACL权限是否开启：

```
[root@localhost ~]# mount
/dev/sda1 on /boot type ext4 (rw)
/dev/sda3 on I type ext4 (rw)
…省略部分输出…
#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置
[root@localhost ~]# dumpe2fs -h /dev/sda3
#dumpe2fs是查询指定分区文件系统详细信息的命令
…省略部分输出…
Default mount options: user_xattr acl
…省略部分输出…
```

> **使用 mount 命令可以查看到系统中已经挂载的分区**，**而使用 dumpe2fs 命令可以查看到这个分区文件系统的详细信息**。大家可以看到，我们的 ACL 权限是 /dev/sda3 分区的默认挂载选项，所以不需要手工挂载。



如果 Linux 系统如果没有默认挂载，可以执行如下命令实现手动挂载：

```
[root@localhost ~]# mount -o remount,acl /
#重新挂载根分区，并加入ACL权限
```



使用 mount 命令重新挂载，并加入 ACL 权限。但使用此命令只是临时生效，**要想永久生效，需要修改 /etc/fstab 文件**，修改方法如下：

```
[root@localhost ~]#vi /etc/fstab
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 /ext4 defaults,acl 1 1
#加入ACL权限
[root@localhost ~]# mount -o remount /
#重新挂载文件系统或重启系统，使修改生效
```

***



## ACL权限设置（setfacl和getfacl）


设定 ACl 权限，常用命令有 2 个，分别是 setfacl 和 getfacl 命令，==前者用于给指定文件或目录设定 ACL 权限，后者用于查看是否配置成功。==





#### `getfacl`

**getfacl 命令用于查看文件或目录当前设定的 ACL 权限信息**

命令格式：

```
[root@localhost ~]# getfacl 文件名
```



#### `setfacl`

**setfacl 命令可直接设定用户或群组对指定文件的访问权限。**

```
[root@localhost ~]# setfacl 选项 文件名
```



​                                                                                      **表 1 setfacl 命令选项及用法**

|  选项   |                             功能                             |
| :-----: | :----------------------------------------------------------: |
| -m 参数 | 设定 ACL 权限。如果是给予用户 ACL 权限，参数则使用 "u:用户名:权限" 的格式，例如 `setfacl -m u:st:rx /project` 表示设定 st 用户对 project 目录具有 rx 权限；如果是给予组 ACL 权限，参数则使用 "g:组名:权限" 格式，例如 `setfacl -m g:tgroup:rx /project` 表示设定群组 tgroup 对 project 目录具有 rx 权限。 |
| -x 参数 | 删除指定用户（参数使用 u:用户名）或群组（参数使用 g:群组名）的 ACL 权限，例如 `setfacl -x u:st /project` 表示删除 st 用户对 project 目录的 ACL 权限。 |
|   -b    | 删除所有的 ACL 权限，例如 `setfacl -b /project` 表示删除有关 project 目录的所有 ACL 权限。 |
|   -d    | 设定默认 ACL 权限，命令格式为 "setfacl -m d:u:用户名:权限 文件名"（如果是群组，则使用 d:g:群组名:权限），==只对目录生效==，指目录中新建立的文件拥有此默认权限，例如 `setfacl -m d:u:st:rx /project` 表示 st 用户对 project 目录中新建立的文件拥有 rx 权限。 |
|   -R    | 递归设定 ACL 权限，指设定的 ACL 权限会对目录下的所有子文件生效，命令格式为 "setfacl -m u:用户名:权限 -R 文件名"（群组使用 g:群组名:权限），例如 `setfacl -m u:st:rx -R /project` 表示 st 用户对已存在于 project 目录中的子文件和子目录拥有 rx 权限。 |
|   -k    |                     删除默认 ACL 权限。                      |



***



### setfacl-m：用户或群组添加ACL权限



**设置过程**



1. 添加需要试验的用户和用户组（useradd/groupadd），省略设定密码的过程

2. 建立需要分配权限的目录 （mkdir/[catalogue](javascript:;)）

3. 改变/[catalogue](javascript:;)目录的所有者和所属组（chown root：group/[catalogue](javascript:;)）

4. 指定目录的权限（chomd 770/[catalogue](javascript:;)）

5. st用户临时进入用户组

6. （# setfacl -m u:st:rx /project）给用户st赋予r-x权限，使用"u:用户名：权限" 格式

7. 如果查询时会发现，在权限位后面多了一个"+"，表示此目录拥有ACL权限

   ```
   [root@localhost /]# ll -d /project
   drwxrwx---+ 2 root tgroup 4096 Apr 16 12:55 /project
   ```

8. 查看/catalogue目录的ACL权限

   ```
   [root@localhost /]# getfacl project
   #查看/prpject目录的ACL权限
   #file:project <--文件名
   #owner:root <--文件的所有者
   #group:tgroup <--文件的所属组
   user::rwx <--用户名栏是空的，说明是所有者的权限
   user:st:r-x <--用户st的权限
   group::rwx <--组名栏是空的，说明是所属组的权限
   mask::rwx <--mask权限
   other::--- <--其他人的权限
   ```

   

> 可以看到，通过设定 ACL 权限，我们可以单独给 st 用户分配 r-x 权限，而无需给 st 用户设定任何身份。



***



### setfacl -d：设定默认ACL权限

既然已经对目录设定了 ACL 权限，那么，如果在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？

执行以下命令进行验证：

```
[root@localhost /]# cd project
[root@localhost project]# touch abc
[root@localhost project]# mkdir d1
#在/project目录中新建了abc文件和d1目录
[root@localhost project]#ll
总用量4
-rw-r--r-- 1 root root 01月19 05:20 abc
drwxr-xr-x 2 root root 4096 1月19 05:20 d1
```

==可以看到，这两个新建立的文件权限位后面并没有 "+"，表示它们没有继承 ACL 权限。这说明，后建立的子文件或子目录，并不会继承父目录的 ACL 权限。==



##### `默认 ACL 权限的作用是，如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。需要注意的是，默认 ACL 权限只对目录生效。`



**对目录设定的默认 ACL 权限，可直接使用 setfacl -k 命令删除。例如：**

```
[root@localhost /]# setfacl -k project
```

***



### setfacl -R:设定递归ACL权限

**递归 ACL 权限指的是父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。**



例如，给 project 目录设定 st 用户访问权限为 rx 的递归 ACL 权限，执行命令如下：

```
[root@localhost project]# setfacl -m u:st:rx -R project
[root@localhost project]# ll
总用量 8
-rw-r-xr--+ 1 root root 01月19 05:20 abc
-rw-rwx--+ 1 root root 01月19 05:33 bcd
drwxr-xr-x+ 2 root root 4096 1月19 05:20 d1
drwxrwx---+ 2 root root 4096 1月19 05:33 d2
#abc和d1也拥有了ACL权限
```



==注意，默认 ACL 权限指的是针对父目录中后续建立的文件和目录会继承父目录的 ACL 权限；递归 ACL 权限指的是针对父目录中已经存在的所有子文件和子目录会继承父目录的 ACL 权限。==

***



### setfacl -x：删除指定的ACL权限

**使用 `setfacl -x` 命令，可以删除指定的 ACL 权限**

例如，删除前面建立的 st 用户对 project 目录的 ACL 权限，执行命令如下：

```
[root@localhost /]# setfacl -x u:st project
#删除指定用户和用户组的ACL权限
[root@localhost /]# getfacl project
# file:project
# owner: root
# group: tgroup
user::rwx
group::rwx
group:tgroup2:rwx
mask::rwx
other::---
#st用户的权限已被删除
```



### setfacl -b：删除指定文件的所有 ACL 权限

**此命令可删除所有与指定文件或目录相关的 ACL 权限。**

例如，现在我们删除一切与 project 目录相关的 ACL 权限，执行命令如下：

```
[root@localhost /]# setfacl -b project
#会删除文件的所有ACL权限
[root@localhost /]# getfacl project
#file: project
#owner: root
# group: tgroup
user::rwx
group::rwx
other::---
#所有ACL权限已被删除
```



## mask有效权限



**mask 权限，指的是用户或群组能拥有的最大 ACL 权限，也就是说，给用户或群组设定的 ACL 权限不能超过 mask 规定的权限范围，超出部分做无效处理。**



> 给 st 用户赋予访问 project 目录的 r-x 权限，此时并不能说明 st 用户就拥有了对该目录的读和访问权限，还需要和 mask 权限对比，r-x 确实是在 rwx 范围内，这时才能说 st 用户拥有 r-x 权限。



**`需要注意的是，这里将权限进行对比的过程，实则是将两权限做“按位相与”运算，最终得出的值，即为 st 用户有效的 ACL 权限。这里以读（r）权限为例，做相与操作的结果如表 1 所示：`**



> 但是，如果把 mask 权限改为 r--，再和 st 用户的权限 r-x 比对（r-- 和 r-w 做与运算），由于 r-w 超出 r-- 的权限范围，因此 st 用户最终只有 r 权限，手动赋予的 w 权限无效。这就是在设定 ACL 权限时 mask 权限的作用。
>
> **它将用户或群组所设定的 ACL 权限限制在 mask 规定的范围内，超出部分直接失效。**



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201043330.png)



mask 权限可以使用 setfacl 命令手动更改，比如，更改 project 目录 mask 权限值为 r-x，可执行如下命令：

```
[root@localhost ~]# setfacl -m m:rx /project
#设定mask权限为r-x，使用"m:权限"格式
[root@localhost ~]# getfacl /project
#file：project
#owner：root
#group：tgroup
user::rwx
group::rwx
mask::r-x  <--mask权限变为r-x
other::---
```

***



## Set UID (SUID)文件特殊权限用法详解



其实除了 rwx 权限，还会用到 s 权限，例如：

```
-rwsr-xr-x. 1 root root 22984 Jan  7  2007 /usr/bin/passwd
```

==可以看到，原本表示文件所有者权限中的 x 权限位，却出现了 s 权限，此种权限通常称为 SetUID，简称 SUID 特殊权限。==


**SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。**



***

> Linux 系统中，绝对多数命令的文件所有者默认都是 root。

当普通用户使用 passwd 命令尝试更改自己的密码时，实际上是在以 root 的身份执行passwd命令，正因为 root 可以将密码写入 /etc/shadow 文件，所以普通用户也能做到。只不过，一旦命令执行完成，普通用户所具有的 root身份也随之消失。



如果我们手动将 /usr/bin/passwd 文件的 SUID 权限取消，会发生什么呢？观察如下命令的执行过程：

```
[root@localhost ~]# chmod u-s /usr/bin/passwd
#属主取消SetUID权限
[root@localhost ~]# ll /usr/bin/passwd
-rwxr-xr-x. 1 root root 30768 Feb 22 2012 /usr/bin/passwd
[root@localhost ~]# su - lamp
[lamp@localhost ~]$ passwd
Changing password for user lamp.
Changing password for user.
(current) UNIX password:
#看起来没有什么问题
New passwor:
Retype new password:
password:Authentication token manipulation error  <--鉴定令牌操作错误
#最后密码没有生效
```

显然，虽然用户有执行 passwd 命令的权限，但无修改 /etc/shadow 文件的权限，因此最终密码修改失败。

==注意，实验完成后，一定要再把 /usr/bin/passwd 文件的 SetUID 权限加上。==



***



![img](https://raw.githubusercontent.com/Lii-ya/PicGO1/main/202304201043931.png)



由此，我们可以总结出，**SUID 特殊权限具有如下特点：**

- 只有可执行文件才能设定 SetUID 权限，对目录设定 SUID，是无效的。
- 用户要对该文件拥有 x（执行）权限。
- 用户在执行该文件时，会以文件所有者的身份执行。
- SetUID 权限只在文件执行过程中有效，一旦执行完毕，身份的切换也随之消失。



***



## Linux文件特殊权限（SUID、SGID、SBIT）的设置



给文件或目录设定SUID、SGID和SBIT特殊权限也可以使用，数字形似和字母形式



> 我们知道，给 chmod 命令传递 3 个数字，即可实现给文件或目录设定普通权限。比如说，"755" 表示所有者拥有 rwx 权限，所属组拥有 rx 权限，其他人拥有 tx 权限。

> 给文件或目录设定特殊权限，只需在这 3 个数字之前增加一个数字位，用来放置给文件或目录设定的特殊权限

***



==**SUID、SGID、SBIT 分别对应的数字**==

```
4 --> SUID
2 --> SGID
1 --> SBIT
```



举个例子，如果要将一个文件权限设置为 -rwsr-xr-x，怎么办呢？

**此文件的普通权限为 755，另外，此文件还有 SUID 权限，==因此只需在 755 的前面，加上 SUID 对应的数字 4 即可==。也就是说，只需执行`chmod 4755 文件名`命令，就完成了-rwsr-xr-x 权限的设定。**



> 同样的道理，如果某文件拥有 SUID 和 SGID 权限，则只需要给 chmod 命令传递 6---（- 表示数字）即可；如果某目录拥有 SGID 和 SBIT，只需要给 chmod 命令传递 3--- 即可。

***



==注意，不同的特殊权限，作用的对象是不同的，SUID 只对可执行文件有效；SGID 对可执行文件和目录都有效；SBIT 只对目录有效。==



给文件设置 7---，也就是将 SUID、SGID、SBIT赋予一个文件或目录，例如：

```
[root@localhost ~]# chmod 7777 ftest
#一次赋予SetUID、SetGID和SBIT权限
[root@localhost ~]# ll ftest
-rwsrwsrwt. 1 root root Apr 19 23:54 ftest
执行过程虽然没有报错，但这样做，没有任何实际意义。

```



#### `除了赋予 chmod 命令 4 个数字设定特殊权限，还可以使用字母的形式。例如，可以通过 "u+s" 给文件赋予 SUID 权限；通过 "g+s" 给文件或目录赋予 SGID 权限；通过 "o+t" 给目录赋予 SBIT 权限。`

```
[root@localhost ~]#chmod u+s, g+s, o+t ftest
#设置特殊权限
[root@localhost ~]# ll ftest
-rwsr-sr-t. 1 root root Apr 19 23:54 ftest
[root@localhost ~]# chmod u-s, g-s, o-t ftest
#取消特殊权限
[root@localhost ~]# ll ftest
-rwxr-xr-x. 1 root root Apr 19 23:54 ftest
```



##### 无论是 SUID、SGID 还是 SBIT，它们只针对具有 x 权限的文件或目录有效。没有 x 权限的文件或目录，即便赋予特殊权限，也无法发挥它们的功能，没有任何意义。


***



## chattr命令详解：修改文件系统的权限属性

管理 Linux 系统中的文件和目录，除了可以设定普通权限和特殊权限外，还可以利用文件和目录具有的一些隐藏属性。



**chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。**

该命令的基本格式为：

```
[root@localhost ~]# chattr [+-=] [属性] 文件或目录名
```

> \+ 表示给文件或目录添加属性，- 表示移除文件或目录拥有的某些属性，= 表示给文件或目录设定一些属性。



| 属性选项 |                             功能                             |
| :------: | :----------------------------------------------------------: |
|    i     | 如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件； |
|    a     | 如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件； |
|    u     | 设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。 |
|    s     | 和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。 |

>
> 给设置有 i 属性的文件删除此属性也很简单，只需将 chattr 命令中 + 改为 - 即可。


==注意，通常情况下，不要使用 chattr 命令修改 /、/dev/、/tmp/、/var/ 等目录的隐藏属性，很容易导致系统无法启动。另外，chatrr 命令常与 lsattr 命令合用，前者修改文件或目录的隐藏属性，后者用于查看是否修改成功。==



##  lsattr命令：查看文件系统属性



使用chatrr命令配置文件或目录的隐藏属性后，可以使用lsattr命令查看。



**用于显示文件或目录的隐藏属性**

命令格式：

```
[root@localhost ~]# lsattr [选项] 文件或目录名
```

> 常用选项有以下 3 种：
>
> - -a：后面不带文件或目录名，表示显示所有文件和目录（包括隐藏文件和目录）
> - -d：如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息；
> - -R：和 -d 恰好相反，作用于目录时，会连同子目录的隐藏信息数据也一并显示出来。



***



## sudo命令用法详解：系统权限管理



使用su命令可以让普通用户切换到root身份去执行某些特权命令。

此命令存在的问题：

- 仅仅为了一个特权操作就直接赋予普通用户控制系统的完整权限；
- 当多人使用同一台主机时，如果大家都要使用 su 命令切换到 root 身份，那势必就需要 root 的密码，这就导致很多人都知道 root 的密码；



**sudo 命令默认只有 root 用户可以运行**，该命令的基本格式为：

```
[root@localhost ~]# sudo [-b] [-u 新使用者账号] 要执行的命令
```

> 常用的选项与参数：
>
> - -b ：将后续的命令放到背景中让系统自行运行，不对当前的 shell 环境产生影响。
> - -u ：后面可以接欲切换的用户名，若无此项则代表切换身份为 root 。
> - -l：此选项的用法为 sudo -l，用于显示当前用户可以用 sudo 执行那些命令。 


sudo命令的运行，需经历如下几步：

- 当用户运行 sudo 命令时，系统会先通过 /etc/sudoers 文件，验证该用户是否有运行 sudo 的权限；
- 确定用户具有使用 sudo 命令的权限后，还要让用户输入自己的密码进行确认。出于对系统安全性的考虑，如果用户在默认时间内（默认是 5 分钟）不使用 sudo 命令，此后使用时需要再次输入密码；
- 密码输入成功后，才会执行 sudo 命令后接的命令。



***



### sudo命令的配置文件/etc/sudoers


**修改 /etc/sudoers，不建议直接使用 vim，而是使用 visudo。因为修改 /etc/sudoers 文件需遵循一定的语法规则，使用 visudo 的好处就在于，当修改完毕 /etc/sudoers 文件，离开修改页面时，系统会自行检验 /etc/sudoers 文件的语法。**



修改 /etc/sudoers 文件的命令如下：

```
[root@localhost ~]# visudo
…省略部分输出…
root ALL=(ALL) ALL  <--大约 76 行的位置
# %wheel ALL=(ALL) ALL   <--大约84行的位置
#这两行是系统为我们提供的模板，我们参照它写自己的就可以了
…省略部分输出…
```



这两行模板的含义分为是：

```
root ALL=(ALL) ALL
#用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
#%wheel ALL=(ALL) ALL
#%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)
```



​                                                                             表 1 /etc/sudoers 用户和群组模板的含义

|       模块       |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
|  用户名或群组名  |     表示系统中的那个用户或群组，可以使用 sudo 这个命令。     |
| 被管理主机的地址 | 用户可以管理指定 IP 地址的服务器。这里如果写 ALL，则代表用户可以管理任何主机；如果写固定 IP，则代表用户可以管理指定的服务器。如果我们在这里写本机的 IP 地址，不代表只允许本机的用户使用指定命令，而是代表指定的用户可以从任何 IP 地址来管理当前服务器。 |
|   可使用的身份   | 就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意身份。这个字段可以省略。 |
|     授权命令     | 表示 root 把什么命令命令授权给用户，换句话说，可以用切换的身份执行什么命令。需要注意的是，此命令必须使用绝对路径写。默认值是 ALL，表示可以执行任何命令。 |



> ==授权命令要使用绝对路径（或者把 /sbin 路径导入普通用户 PATH 路径中，不推荐使用此方式），否则无法执行。==

 
